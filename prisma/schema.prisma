generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
  runtime         = "nodejs"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
  extensions        = [postgis()]
}

model Guest {
  id     String  @id @default(cuid())
  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id], name: "UserGuest")

  device_token String   @unique
  device_info  Json
  push_token   String?
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  @@index([device_token], name: "idx_guest_device_token")
}

model User {
  id                 String   @id @default(cuid())
  email              String
  password           String
  temporary_password String?
  first_access       Boolean  @default(false)
  name               String
  document_number    String?
  push_token         String?
  user_type          UserType
  created_at         DateTime @default(now())
  updated_at         DateTime @updatedAt

  // NOVO: vínculo canônico para o tipo customer
  personId String? @unique
  person   Person? @relation("UserPerson", fields: [personId], references: [id])

  // ...demais relações existentes inalteradas...
  businesses              Business[]                @relation("BusinessOwners")
  professional_profile    ProfessionalProfile[]
  CurrentSelectedBusiness CurrentSelectedBusiness[]
  guest                   Guest?                    @relation(name: "UserGuest")
  UploadedMedia           UploadedMedia[]
  BusinessRating          BusinessRating[]

  @@unique([email, user_type], name: "uq_user_email_type")
  @@index([email, user_type], name: "idx_user_email_user_type")
}

model Business {
  id                       String                    @id @default(cuid())
  name                     String
  slug                     String                    @unique
  description              String?
  logo                     String?
  coverImage               String?
  latitude                 Float // Latitude para localização
  longitude                Float // Longitude para localização
  location                 Unsupported("geography")? @map("location")
  opening_hours            Json
  website                  String?
  instagram                String?
  email                    String?
  public_type              BusinessPublicType        @default(BOTH)
  business_category_custom String? // categoria customizada, se aplicável
  is_active                Boolean                   @default(true)
  is_verified              Boolean                   @default(false)
  is_featured              Boolean                   @default(false)
  rating                   Float                     @default(0.0)
  reviews_count            Int                       @default(0)
  total_one_star           Int                       @default(0)
  total_two_star           Int                       @default(0)
  total_three_star         Int                       @default(0)
  total_four_star          Int                       @default(0)
  total_five_star          Int                       @default(0)
  average_price            Float                     @default(0.0) // preço médio dos serviços
  stripe_customer_id       String? // ID do cliente no Stripe, se aplicável
  phone                    String?
  zipCode                  String?
  street                   String?
  neighbourhood            String?
  number                   String?
  complement               String?
  city                     String?
  uf                       String?
  ownerId                  String
  owner                    User                      @relation("BusinessOwners", fields: [ownerId], references: [id])
  professionals            ProfessionalProfile[]
  services                 Service[]
  created_at               DateTime                  @default(now())
  updated_at               DateTime                  @updatedAt
  BusinessCategory         BusinessCategory?         @relation(fields: [businessCategoryId], references: [id])
  businessCategoryId       String?
  BusinessServiceType      BusinessServiceType?      @relation(fields: [businessServiceTypeId], references: [id])
  businessServiceTypeId    String?
  BusinessSubscription     BusinessSubscription[]
  CurrentSelectedBusiness  CurrentSelectedBusiness[]
  ProfessionalStatement    ProfessionalStatement[]
  BusinessCustomer         BusinessCustomer[]
  BusinessRating           BusinessRating[]

  @@index([slug], name: "idx_business_slug")
  @@index([name], name: "idx_business_name")
  @@index([ownerId], name: "idx_business_owner")
  @@index([businessCategoryId], name: "idx_business_category")
  @@index([businessServiceTypeId], name: "idx_business_service_type")
}

model BusinessRating {
  id         String   @id @default(cuid())
  rating     Int // 1 a 5
  review     String? // comentário opcional
  created_at DateTime @default(now())

  business      Business @relation(fields: [business_slug], references: [slug])
  user          User     @relation(fields: [userId], references: [id])
  business_slug String
  userId        String

  @@unique([business_slug, userId], name: "uq_business_user_rating") // um usuário só pode avaliar um negócio uma vez
  @@index([business_slug], name: "idx_business_rating_business")
  @@index([userId], name: "idx_business_rating_user")
}

model CurrentSelectedBusiness {
  id         String   @id @default(cuid())
  userId     String   @unique
  businessId String
  user       User     @relation(fields: [userId], references: [id])
  business   Business @relation(fields: [businessId], references: [id])

  @@index([userId], name: "idx_current_selected_business_user")
  @@index([businessId], name: "idx_current_selected_business_business")
}

model Service {
  id             String                @id @default(cuid())
  name           String
  duration       Int // Minutos
  price_in_cents Int // preço padrão do serviço
  businessId     String
  business       Business              @relation(fields: [businessId], references: [id])
  appointments   Appointment[]
  professionals  ProfessionalService[] // relação com a pivot
  created_at     DateTime              @default(now())
  updated_at     DateTime              @updatedAt

  @@unique([name, businessId]) // evita duplicidade de serviços no mesmo negócio
  @@index([name], name: "idx_service_name")
  @@index([businessId], name: "idx_service_business")
}

model ProfessionalProfile {
  id String @id @default(cuid())

  business_id   String
  business      Business              @relation(fields: [business_id], references: [id])
  services      ProfessionalService[] // relação com a pivot
  bio           String?
  phone         String?
  profile_image String?

  status                ProfessionalStatus      @default(ACTIVE) // status do profissional
  created_at            DateTime                @default(now())
  updated_at            DateTime                @updatedAt
  rating                Float                   @default(0.0)
  reviewsCount          Int                     @default(0)
  averagePrice          Float                   @default(0.0) // preço médio dos serviços oferecidos
  //availability Json?             // JSON com horários disponíveis (ex: {"Monday": ["09:00", "17:00"], "Tuesday": ["10:00", "18:00"]})
  User                  User?                   @relation(fields: [userId], references: [id])
  userId                String?
  in_app_notification   InAppNotification[]
  Appointment           Appointment[]
  ProfessionalStatement ProfessionalStatement[]

  @@index([business_id], name: "idx_professional_business")
  @@index([userId], name: "idx_professional_user")
}

model ProfessionalService {
  id                      String  @id @default(cuid())
  professional_profile_id String
  service_id              String
  custom_price            Float? // se diferente do padrão
  active                  Boolean @default(true)
  order                   Int? // para ordenação opcional

  professional_profile ProfessionalProfile @relation(fields: [professional_profile_id], references: [id])
  service              Service             @relation(fields: [service_id], references: [id])

  @@unique([professional_profile_id, service_id]) // evita duplicidade
  @@index([professional_profile_id], name: "idx_professional_service_profile")
  @@index([service_id], name: "idx_professional_service_service")
}

model ProfessionalStatement {
  id             String        @id @default(cuid())
  type           StatementType
  description    String
  value_in_cents Int
  created_at     DateTime      @default(now())

  business Business @relation(fields: [businessId], references: [id])

  professional_profile  ProfessionalProfile @relation(fields: [professionalProfileId], references: [id])
  professionalProfileId String

  appointment   Appointment? @relation(fields: [appointmentId], references: [id])
  appointmentId String?
  businessId    String

  @@index([professionalProfileId], name: "idx_professional_statement_profile")
  @@index([businessId], name: "idx_professional_statement_business")
}

model Appointment {
  id           String            @id @default(cuid())
  service_id   String
  scheduled_at DateTime
  status       AppointmentStatus
  notes        String?
  events       Json              @default(dbgenerated("'[]'::jsonb"))

  professional   ProfessionalProfile @relation(fields: [professionalProfileId], references: [id])
  service        Service             @relation(fields: [service_id], references: [id])
  customerPerson Person              @relation(fields: [personId], references: [id])

  created_at            DateTime                @default(now())
  updated_at            DateTime                @updatedAt
  professionalProfileId String
  ProfessionalStatement ProfessionalStatement[]
  personId              String

  @@index([service_id], name: "idx_appointment_service")
  @@index([professionalProfileId, scheduled_at], name: "idx_professional_date")
  @@index([personId], name: "idx_appointment_person")
}

// Vincular pessoa como user do tipo Customer e vincular como cliente das empresas
model Person {
  id              String  @id @default(cuid())
  // Identificadores para dedupe e match automático
  document_number String? @unique // CPF/CNPJ, limpo e sem máscara
  email           String? @unique // email em minúsculas
  phone           String? @unique // telefone em E.164 (ex: +552199...)

  // Dados básicos
  name          String
  birthdate     DateTime? @db.Date // mantenho como String se preferir
  profile_image String?

  // Auditoria
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  // Relacionamentos
  user              User?               @relation("UserPerson")
  businessLinks     BusinessCustomer[]
  Appointment       Appointment[]
  InAppNotification InAppNotification[]

  @@index([email], name: "idx_person_email")
}

model BusinessCustomer {
  id         String @id @default(cuid())
  businessId String
  personId   String

  // Propriedades específicas do relacionamento com o negócio
  notes    String?
  verified Boolean @default(false)

  // Caso queira manter email/phone “do cadastro do negócio”, deixe como sombra/opcional
  email String?
  phone String?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  business Business @relation(fields: [businessId], references: [id])
  person   Person   @relation(fields: [personId], references: [id])

  @@unique([businessId, personId], name: "uq_business_person")
  @@index([businessId], name: "idx_bc_business")
  @@index([personId], name: "idx_bc_person")
}

model BusinessCategory {
  id              String     @id @default(cuid())
  name            String     @unique
  description     String?
  order           Int? // para ordenação na exibição
  icon_path       String? // caminho ou URL do ícone
  icon_path_light String? // caminho ou URL do ícone
  businesses      Business[]

  @@index([name], name: "idx_business_category_name")
}

model BusinessServiceType {
  id          String     @id @default(cuid())
  name        String     @unique
  description String?
  businesses  Business[]

  @@index([name], name: "idx_business_service_type_name")
}

model InAppNotification {
  id                    String               @id @default(cuid())
  title                 String
  message               String
  read                  Boolean              @default(false)
  is_visible            Boolean              @default(true)
  // type                 String // tipo da notificação (ex: "appointment", "message", etc.)
  professional_profile  ProfessionalProfile? @relation(fields: [professionalProfileId], references: [id])
  person                Person?              @relation(fields: [personId], references: [id])
  created_at            DateTime             @default(now())
  updated_at            DateTime             @updatedAt
  professionalProfileId String
  personId              String?

  @@index([professionalProfileId], name: "idx_notification_professional")
  @@index([personId], name: "idx_notification_person")
  @@index([created_at], name: "idx_notification_created_at")
  @@index([is_visible], name: "idx_notification_visible")
}

model Plan {
  id              String        @id @default(cuid())
  name            String
  description     String?
  stripeProductId String
  stripePriceId   String        @unique // ID do preço no Stripe (price_xxxxx)
  price_in_cents  Int
  billing_period  BillingPeriod @default(MONTHLY) // mensal, anual...
  is_active       Boolean       @default(true)
  showing_order   Int? // para ordenação na exibição

  businesses BusinessSubscription[]

  created_at  DateTime      @default(now())
  updated_at  DateTime      @updatedAt
  PlanBenefit PlanBenefit[]

  @@index([stripeProductId])
  @@index([stripePriceId])
}

model PlanBenefit {
  id          String     @id @default(cuid())
  planId      String
  key         BenefitKey
  order       Int? // ajuda a manter a ordem de exibição
  stringValue String? // “Starter”, “Avançado”, “Ilimitado”…
  intValue    Int? // 1, 5, 10…
  boolValue   Boolean? // ✓ / ✗
  created_at  DateTime   @default(now())

  plan Plan @relation(fields: [planId], references: [id])

  @@unique([planId, key]) // um único valor por chave em cada plano
  @@index([planId])
}

model BusinessSubscription {
  id                   String             @id @default(cuid())
  businessId           String
  planId               String
  stripeCustomerId     String
  stripeSubscriptionId String? // subscription_id do Stripe
  status               SubscriptionStatus @default(ACTIVE)
  current_period_start DateTime?
  current_period_end   DateTime?
  cancel_at_period_end Boolean            @default(false)

  business               Business              @relation(fields: [businessId], references: [id])
  plan                   Plan                  @relation(fields: [planId], references: [id])
  subscription_histories SubscriptionHistory[]

  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  Payment    Payment[]

  @@index([businessId])
  @@index([stripeCustomerId])
}

model SubscriptionHistory {
  id                     String             @id @default(cuid())
  businessSubscriptionId String
  action                 SubscriptionAction
  previousPlanId         String? // caso tenha vindo de outro plano
  newPlanId              String? // novo plano
  actionDate             DateTime           @default(now())
  reason                 String? // opcional, motivo da mudança

  businessSubscription BusinessSubscription @relation(fields: [businessSubscriptionId], references: [id])

  @@index([businessSubscriptionId])
}

model Payment {
  id                     String        @id @default(cuid())
  businessSubscriptionId String
  stripeInvoiceId        String        @unique
  amount_paid_in_cents   Int
  currency               String
  paid_at                DateTime
  status                 PaymentStatus

  businessSubscription BusinessSubscription @relation(fields: [businessSubscriptionId], references: [id])

  created_at DateTime @default(now())

  @@index([businessSubscriptionId])
  @@index([stripeInvoiceId])
}

model WebhookEvent {
  id          String   @id @default(cuid())
  event_id    String   @unique
  type        String
  payload     Json
  received_at DateTime @default(now())

  @@index([event_id])
  @@index([type])
}

model UploadedMedia {
  id          String              @id @default(cuid())
  key         String              @unique // chave do objeto no S3
  etag        String?
  source      UploadedMediaSource
  uploaded_by User                @relation(fields: [userId], references: [id])
  created_at  DateTime            @default(now())
  userId      String

  @@index([source], name: "idx_uploaded_media_source")
  @@index([userId], name: "idx_uploaded_media_user")
}

model MailTemplate {
  id          String   @id @default(cuid())
  description String
  type        String
  subject     String
  pre_header  String?
  html        String   @db.Text
  from        String
  active      Boolean  @default(true)
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  @@unique([type, active], name: "uq_mail_template_type_active")
}

model MailValidation {
  id           String    @id @default(cuid())
  email        String
  code         String
  type         String
  active       Boolean   @default(true)
  expires_at   DateTime
  message_id   String?
  validated    Boolean   @default(false)
  validated_at DateTime?
  created_at   DateTime  @default(now())

  @@index([email], name: "idx_mail_validation_email")
  @@index([code], name: "idx_mail_validation_code")
}

enum UploadedMediaSource {
  BUSINESS_LOGO
  BUSINESS_COVER
  PROFESSIONAL_AVATAR
  CUSTOMER_AVATAR
  SERVICE_IMAGE
}

enum UserType {
  ADMIN
  CUSTOMER
  PROFESSIONAL
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  CANCELED
  COMPLETED
}

enum BillingPeriod {
  MONTHLY
  YEARLY
  FREE_TRIAL
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  INCOMPLETE
  INCOMPLETE_EXPIRED
  TRIALING
  UNPAID
}

enum SubscriptionAction {
  CREATED
  UPDATED
  CANCELED
  RENEWED
}

enum PaymentStatus {
  PAID
  FAILED
  PENDING
}

enum ProfessionalStatus {
  ACTIVE
  INACTIVE
  PENDING_VERIFICATION
}

enum BenefitKey {
  PROFESSIONALS // Nº de profissionais que podem ser criados
  REMINDER_CHANNELS // Canais de lembrete (APP, WPP, E-mail)
  CONFIRMATION_ENABLED // Confirmação automática de agendamento
  WAITING_LIST_ENABLED // Lista de espera habilitada?
  REVIEW_REQUEST_ENABLED // Enviar pedido de avaliação após atendimento?
  APP_POSITION // Posição do negócio no app de clientes
}

enum StatementType {
  INCOME
  OUTCOME
}

enum BusinessPublicType {
  MALE
  FEMALE
  BOTH
}
