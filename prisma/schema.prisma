generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
  runtime         = "nodejs"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
  extensions        = [postgis()]
}

model Guest {
  id           String      @id @default(cuid())
  userId       String?     @unique
  user         User?       @relation(fields: [userId], references: [id], name: "UserGuest")
  origin       GuestOrigin @default(APP)
  device_token String      @unique
  device_info  Json
  push_token   String?
  created_at   DateTime    @default(now())
  updated_at   DateTime    @updatedAt

  @@index([device_token], name: "idx_guest_device_token")
}

model User {
  id                 String   @id @default(cuid())
  email              String
  password           String
  temporary_password String?
  first_access       Boolean  @default(false)
  name               String
  document_number    String?
  push_token         String?
  user_type          UserType
  created_at         DateTime @default(now())
  updated_at         DateTime @updatedAt

  personId String? @unique
  person   Person? @relation("UserPerson", fields: [personId], references: [id])

  businesses              Business[]                @relation("BusinessOwners")
  professional_profile    ProfessionalProfile[]
  CurrentSelectedBusiness CurrentSelectedBusiness[]
  guest                   Guest?                    @relation(name: "UserGuest")
  UploadedMedia           UploadedMedia[]
  BusinessRating          BusinessRating[]
  BugReports              BugReports[]

  @@unique([email, user_type], name: "uq_user_email_type")
  @@index([email, user_type], name: "idx_user_email_user_type")
}

model Business {
  id                       String                    @id @default(cuid())
  name                     String
  slug                     String                    @unique
  description              String?
  logo                     String?
  coverImage               String?
  latitude                 Float // Latitude para localização
  longitude                Float // Longitude para localização
  location                 Unsupported("geography")? @map("location")
  opening_hours            Json
  website                  String?
  instagram                String?
  email                    String?
  public_type              BusinessPublicType        @default(BOTH)
  business_category_custom String? // categoria customizada, se aplicável
  is_active                Boolean                   @default(true)
  is_verified              Boolean                   @default(false)
  is_featured              Boolean                   @default(false)
  rating                   Float                     @default(0.0)
  reviews_count            Int                       @default(0)
  total_one_star           Int                       @default(0)
  total_two_star           Int                       @default(0)
  total_three_star         Int                       @default(0)
  total_four_star          Int                       @default(0)
  total_five_star          Int                       @default(0)
  average_price            Float                     @default(0.0) // preço médio dos serviços
  stripe_customer_id       String? // ID do cliente no Stripe, se aplicável
  phone                    String?
  zipCode                  String?
  street                   String?
  neighbourhood            String?
  number                   String?
  complement               String?
  city                     String?
  uf                       String?
  ownerId                  String
  owner                    User                      @relation("BusinessOwners", fields: [ownerId], references: [id])
  professionals            ProfessionalProfile[]
  services                 Service[]
  created_at               DateTime                  @default(now())
  updated_at               DateTime                  @updatedAt
  BusinessCategory         BusinessCategory?         @relation(fields: [businessCategoryId], references: [id])
  businessCategoryId       String?
  BusinessServiceType      BusinessServiceType?      @relation(fields: [businessServiceTypeId], references: [id])
  businessServiceTypeId    String?
  BusinessSubscription     BusinessSubscription[]
  CurrentSelectedBusiness  CurrentSelectedBusiness[]
  ProfessionalStatement    ProfessionalStatement[]
  BusinessCustomer         BusinessCustomer[]
  BusinessRating           BusinessRating[]
  Favorites                Favorite[]
  BusinessReminderSettings BusinessReminderSettings?
  ReminderJob              ReminderJob[]

  @@index([slug], name: "idx_business_slug")
  @@index([name], name: "idx_business_name")
  @@index([ownerId], name: "idx_business_owner")
  @@index([businessCategoryId], name: "idx_business_category")
  @@index([businessServiceTypeId], name: "idx_business_service_type")
}

model BusinessReminderSettings {
  id         String   @id @default(cuid())
  businessId String   @unique
  business   Business @relation(fields: [businessId], references: [id])

  // Ex.: [1440, 180, 60] => 24h, 3h e 1h antes
  offsets_min_before Int[] @default([1440, 60])

  // Canais habilitados para o negócio
  channels ReminderChannel[] @default([PUSH])

  timezone String @default("America/Sao_Paulo")

  is_active  Boolean  @default(true)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model ReminderJob {
  id               String            @id @default(cuid())
  businessId       String
  appointmentId    String
  personId         String
  channel          ReminderChannel
  due_at_utc       DateTime // quando disparar (UTC)
  scheduled_at_utc DateTime?
  sent_at_utc      DateTime?
  status           ReminderJobStatus @default(PENDING)
  error            String?
  attempts         Int               @default(0)
  metadata         Json?

  business    Business    @relation(fields: [businessId], references: [id])
  appointment Appointment @relation(fields: [appointmentId], references: [id])
  person      Person      @relation(fields: [personId], references: [id])

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  // Evita duplicar o mesmo lembrete do mesmo agendamento/canal/hora
  @@unique([appointmentId, channel, due_at_utc], name: "uq_job_apt_channel_due")
  @@index([status, due_at_utc], name: "idx_job_status_due")
  @@index([businessId], name: "idx_job_business")
  @@index([appointmentId], name: "idx_job_appointment")
}

model BusinessRating {
  id         String   @id @default(cuid())
  rating     Int // 1 a 5
  review     String? // comentário opcional
  created_at DateTime @default(now())

  business      Business @relation(fields: [business_slug], references: [slug])
  user          User     @relation(fields: [userId], references: [id])
  business_slug String
  userId        String

  @@unique([business_slug, userId], name: "uq_business_user_rating") // um usuário só pode avaliar um negócio uma vez
  @@index([business_slug], name: "idx_business_rating_business")
  @@index([userId], name: "idx_business_rating_user")
}

model CurrentSelectedBusiness {
  id         String   @id @default(cuid())
  userId     String   @unique
  businessId String
  user       User     @relation(fields: [userId], references: [id])
  business   Business @relation(fields: [businessId], references: [id])

  @@index([userId], name: "idx_current_selected_business_user")
  @@index([businessId], name: "idx_current_selected_business_business")
}

model Service {
  id             String                @id @default(cuid())
  name           String
  duration       Int // Minutos
  price_in_cents Int // preço padrão do serviço
  businessId     String
  business       Business              @relation(fields: [businessId], references: [id])
  is_active      Boolean               @default(true)
  appointments   Appointment[]
  professionals  ProfessionalService[] // relação com a pivot
  created_at     DateTime              @default(now())
  updated_at     DateTime              @updatedAt

  @@unique([name, businessId]) // evita duplicidade de serviços no mesmo negócio
  @@index([name], name: "idx_service_name")
  @@index([businessId], name: "idx_service_business")
}

model ProfessionalProfile {
  id String @id @default(cuid())

  business_id   String
  business      Business              @relation(fields: [business_id], references: [id])
  services      ProfessionalService[] // relação com a pivot
  bio           String?
  phone         String?
  profile_image String?

  status                ProfessionalStatus      @default(ACTIVE) // status do profissional
  created_at            DateTime                @default(now())
  updated_at            DateTime                @updatedAt
  rating                Float                   @default(0.0)
  reviewsCount          Int                     @default(0)
  averagePrice          Float                   @default(0.0) // preço médio dos serviços oferecidos
  //availability Json?             // JSON com horários disponíveis (ex: {"Monday": ["09:00", "17:00"], "Tuesday": ["10:00", "18:00"]})
  User                  User?                   @relation(fields: [userId], references: [id])
  userId                String?
  in_app_notification   InAppNotification[]
  Appointment           Appointment[]
  ProfessionalStatement ProfessionalStatement[]

  @@index([business_id], name: "idx_professional_business")
  @@index([userId], name: "idx_professional_user")
  @@index([business_id, id], name: "idx_professional_business_id")
}

model ProfessionalService {
  id                      String  @id @default(cuid())
  professional_profile_id String
  service_id              String
  custom_price            Float? // se diferente do padrão
  active                  Boolean @default(true)
  order                   Int? // para ordenação opcional

  professional_profile ProfessionalProfile @relation(fields: [professional_profile_id], references: [id])
  service              Service             @relation(fields: [service_id], references: [id])

  @@unique([professional_profile_id, service_id]) // evita duplicidade
  @@index([professional_profile_id], name: "idx_professional_service_profile")
  @@index([service_id], name: "idx_professional_service_service")
}

model ProfessionalStatement {
  id             String        @id @default(cuid())
  type           StatementType
  description    String
  value_in_cents Int
  created_at     DateTime      @default(now())

  business Business @relation(fields: [businessId], references: [id])

  professional_profile  ProfessionalProfile @relation(fields: [professionalProfileId], references: [id])
  professionalProfileId String

  appointment   Appointment? @relation(fields: [appointmentId], references: [id])
  appointmentId String?
  businessId    String

  @@index([professionalProfileId], name: "idx_professional_statement_profile")
  @@index([businessId], name: "idx_professional_statement_business")
  @@index([businessId, type, created_at], name: "idx_ps_business_type_created_at")
}

model Appointment {
  id         String            @id @default(cuid())
  service_id String
  status     AppointmentStatus
  notes      String?

  // Sempre UTC
  start_at_utc DateTime
  end_at_utc   DateTime

  // Contexto de fuso e fotografia da duração
  timezone             String @default("America/Sao_Paulo")
  start_offset_minutes Int // ex.: -180
  duration_minutes     Int

  professional   ProfessionalProfile @relation(fields: [professionalProfileId], references: [id])
  service        Service             @relation(fields: [service_id], references: [id])
  customerPerson Person              @relation(fields: [personId], references: [id])

  created_at            DateTime                @default(now())
  updated_at            DateTime                @updatedAt
  professionalProfileId String
  personId              String
  events                AppointmentEvent[]
  ProfessionalStatement ProfessionalStatement[]
  ReminderJob           ReminderJob[]

  @@index([service_id], name: "idx_appointment_service")
  @@index([personId], name: "idx_appointment_person")
  @@index([professionalProfileId, start_at_utc], name: "idx_professional_start")
  @@index([professionalProfileId, end_at_utc], name: "idx_professional_end")
}

model AppointmentEvent {
  id            String      @id @default(cuid())
  appointmentId String
  appointment   Appointment @relation(fields: [appointmentId], references: [id])

  event_type      AppointmentEventType
  by_professional Boolean
  by_user_id      String?
  reason          String?
  ip              String?              @db.VarChar(64)
  user_agent      String?
  created_at      DateTime             @default(now())

  @@index([appointmentId], name: "idx_appointment_event_appointment")
}

// Vincular pessoa como user do tipo Customer e vincular como cliente das empresas
model Person {
  id              String  @id @default(cuid())
  // Identificadores para dedupe e match automático
  document_number String? @unique // CPF/CNPJ, limpo e sem máscara
  email           String? @unique // email em minúsculas
  phone           String? @unique // telefone em E.164 (ex: +552199...)

  // Dados básicos
  name          String
  birthdate     DateTime? @db.Date // mantenho como String se preferir
  profile_image String?

  preferred_content_genre BusinessPublicType? // masculino, feminino, ambos

  // Auditoria
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  // Relacionamentos
  user              User?               @relation("UserPerson")
  businessLinks     BusinessCustomer[]
  Appointment       Appointment[]
  InAppNotification InAppNotification[]
  favorites         Favorite[]
  ReminderJob       ReminderJob[]

  @@index([email], name: "idx_person_email")
}

model Favorite {
  id         String   @id @default(cuid())
  personId   String
  businessId String
  created_at DateTime @default(now())

  person   Person   @relation(fields: [personId], references: [id])
  business Business @relation(fields: [businessId], references: [id])

  @@unique([personId, businessId], name: "uq_favorite_person_business")
  @@index([personId], name: "idx_favorite_person")
  @@index([businessId], name: "idx_favorite_business")
}

model BusinessCustomer {
  id         String @id @default(cuid())
  businessId String
  personId   String

  // Propriedades específicas do relacionamento com o negócio
  notes      String?
  verified   Boolean @default(false)
  is_blocked Boolean @default(false)

  // Caso queira manter email/phone “do cadastro do negócio”, deixe como sombra/opcional
  email String?
  phone String?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  business Business @relation(fields: [businessId], references: [id])
  person   Person   @relation(fields: [personId], references: [id])

  @@unique([businessId, personId], name: "uq_business_person")
  @@index([businessId], name: "idx_bc_business")
  @@index([personId], name: "idx_bc_person")
  @@index([businessId, created_at], name: "idx_bc_business_created_at")
}

model BusinessCategory {
  id              String     @id @default(cuid())
  name            String     @unique
  description     String?
  order           Int? // para ordenação na exibição
  icon_path       String? // caminho ou URL do ícone
  icon_path_light String? // caminho ou URL do ícone
  businesses      Business[]

  @@index([name], name: "idx_business_category_name")
}

model BusinessServiceType {
  id          String     @id @default(cuid())
  name        String     @unique
  description String?
  businesses  Business[]

  @@index([name], name: "idx_business_service_type_name")
}

model InAppNotification {
  id                    String               @id @default(cuid())
  title                 String
  message               String
  read                  Boolean              @default(false)
  is_visible            Boolean              @default(true)
  // type                 String // tipo da notificação (ex: "appointment", "message", etc.)
  professional_profile  ProfessionalProfile? @relation(fields: [professionalProfileId], references: [id])
  person                Person?              @relation(fields: [personId], references: [id])
  created_at            DateTime             @default(now())
  updated_at            DateTime             @updatedAt
  professionalProfileId String
  personId              String?

  @@index([professionalProfileId], name: "idx_notification_professional")
  @@index([personId], name: "idx_notification_person")
  @@index([created_at], name: "idx_notification_created_at")
  @@index([is_visible], name: "idx_notification_visible")
}

model Plan {
  id              String        @id @default(cuid())
  name            String
  description     String?
  stripeProductId String
  stripePriceId   String        @unique // ID do preço no Stripe (price_xxxxx)
  price_in_cents  Int
  billing_period  BillingPeriod @default(MONTHLY) // mensal, anual...
  is_active       Boolean       @default(true)
  showing_order   Int? // para ordenação na exibição

  businesses BusinessSubscription[]

  created_at  DateTime      @default(now())
  updated_at  DateTime      @updatedAt
  PlanBenefit PlanBenefit[]

  @@index([stripeProductId])
  @@index([stripePriceId])
}

model PlanBenefit {
  id          String     @id @default(cuid())
  planId      String
  key         BenefitKey
  order       Int? // ajuda a manter a ordem de exibição
  stringValue String? // “Starter”, “Avançado”, “Ilimitado”…
  intValue    Int? // 1, 5, 10…
  boolValue   Boolean? // ✓ / ✗
  created_at  DateTime   @default(now())

  plan Plan @relation(fields: [planId], references: [id])

  @@unique([planId, key]) // um único valor por chave em cada plano
  @@index([planId])
}

model BusinessSubscription {
  id                   String             @id @default(cuid())
  businessId           String
  planId               String
  stripeCustomerId     String
  stripeSubscriptionId String? // subscription_id do Stripe
  status               SubscriptionStatus @default(ACTIVE)
  current_period_start DateTime?
  current_period_end   DateTime?
  cancel_at_period_end Boolean            @default(false)

  business               Business              @relation(fields: [businessId], references: [id])
  plan                   Plan                  @relation(fields: [planId], references: [id])
  subscription_histories SubscriptionHistory[]

  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  Payment    Payment[]

  @@index([businessId])
  @@index([stripeCustomerId])
}

model SubscriptionHistory {
  id                     String             @id @default(cuid())
  businessSubscriptionId String
  action                 SubscriptionAction
  previousPlanId         String? // caso tenha vindo de outro plano
  newPlanId              String? // novo plano
  actionDate             DateTime           @default(now())
  reason                 String? // opcional, motivo da mudança

  businessSubscription BusinessSubscription @relation(fields: [businessSubscriptionId], references: [id])

  @@index([businessSubscriptionId])
}

model Payment {
  id                     String        @id @default(cuid())
  businessSubscriptionId String
  stripeInvoiceId        String        @unique
  amount_paid_in_cents   Int
  currency               String
  paid_at                DateTime
  status                 PaymentStatus

  businessSubscription BusinessSubscription @relation(fields: [businessSubscriptionId], references: [id])

  created_at DateTime @default(now())

  @@index([businessSubscriptionId])
  @@index([stripeInvoiceId])
}

model WebhookEvent {
  id          String   @id @default(cuid())
  event_id    String   @unique
  type        String
  payload     Json
  received_at DateTime @default(now())

  @@index([event_id])
  @@index([type])
}

model UploadedMedia {
  id          String              @id @default(cuid())
  key         String              @unique // chave do objeto no S3
  etag        String?
  source      UploadedMediaSource
  uploaded_by User                @relation(fields: [userId], references: [id])
  created_at  DateTime            @default(now())
  userId      String

  @@index([source], name: "idx_uploaded_media_source")
  @@index([userId], name: "idx_uploaded_media_user")
}

model MailTemplate {
  id          String   @id @default(cuid())
  description String
  type        String
  subject     String
  pre_header  String?
  html        String   @db.Text
  from        String
  active      Boolean  @default(true)
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  @@unique([type, active], name: "uq_mail_template_type_active")
}

model MailValidation {
  id              String                @id @default(cuid())
  request_id      String                @unique
  email           String
  message_id      String?
  code_ciphertext String
  code_iv         String
  type            String
  status          EmailValidationStatus @default(PENDING)
  user_type       UserType
  attempts        Int                   @default(0)
  active          Boolean               @default(true)
  expires_at      DateTime
  validated       Boolean               @default(false)
  validated_at    DateTime?
  created_at      DateTime              @default(now())

  events MailValidationEvent[]

  @@index([email], name: "idx_mail_validation_email")
  @@index([request_id], name: "idx_mail_validation_request")
}

model MailValidationEvent {
  id               String         @id @default(cuid())
  mailValidationId String
  validation       MailValidation @relation(fields: [mailValidationId], references: [id], onDelete: Restrict)

  event_type      EmailValidationEventType
  message         String?                  @db.VarChar(255)
  code_ciphertext String
  code_iv         String
  attempt_no      Int?
  ip              String?                  @db.VarChar(64)
  user_agent      String?
  metadata        Json?
  created_at      DateTime                 @default(now())

  @@index([mailValidationId, created_at], name: "idx_mail_event_stream")
}

model WhatsAppValidation {
  id                  String                    @id @default(cuid())
  request_id          String                    @unique
  phone_number        String
  whatsapp_message_id String?
  code_ciphertext     String
  code_iv             String
  type                String
  status              WhatsAppValidationStatus  @default(PENDING)
  user_type           UserType
  attempts            Int                       @default(0)
  active              Boolean                   @default(true)
  expires_at          DateTime
  validated           Boolean                   @default(false)
  validated_at        DateTime?
  created_at          DateTime                  @default(now())
  events              WhatsAppValidationEvent[]

  @@index([phone_number], name: "idx_whatsapp_validation_phone")
  @@index([request_id], name: "idx_whatsapp_validation_request")
}

model WhatsAppValidationEvent {
  id                   String             @id @default(cuid())
  whatsAppValidationId String
  validation           WhatsAppValidation @relation(fields: [whatsAppValidationId], references: [id], onDelete: Restrict)

  event_type      WhatsAppValidationEventType
  message         String?                     @db.VarChar(255)
  code_ciphertext String
  code_iv         String
  attempt_no      Int?
  ip              String?                     @db.VarChar(64)
  user_agent      String?
  metadata        Json?
  created_at      DateTime                    @default(now())

  @@index([whatsAppValidationId, created_at], name: "idx_wv_event_stream")
}

model BugReports {
  id          String   @id @default(cuid())
  description String   @db.Text
  user        User     @relation(fields: [userId], references: [id])
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  userId String

  @@index([userId], name: "idx_bug_report_user")
}

model Logs {
  id           String   @id @default(cuid())
  body         Json?
  query        Json?
  method       String   @db.VarChar(10)
  endpoint     String
  response     Json?
  success      Boolean
  user_id      String?
  device_token String?
  datetime     String
  latencyMs    Int?
  created_at   DateTime @default(now())

  @@index([user_id], name: "idx_logs_taxnumber")
  @@index([device_token], name: "idx_logs_device_token")
}

// ENUMS

enum GuestOrigin {
  APP
  WEB
}

enum ReminderChannel {
  PUSH
  WHATSAPP
}

enum ReminderJobStatus {
  PENDING
  SCHEDULED
  SENT
  FAILED
  CANCELED
  SKIPPED
}

enum EmailValidationStatus {
  PENDING
  SENT
  FAILED
  VALIDATED
}

enum EmailValidationEventType {
  CREATED
  SENT_REQUEST
  DELIVERY_CONFIRMED
  VALIDATION_ATTEMPT
  VALIDATION_SUCCESS
  VALIDATION_FAILED
  EXPIRED
  BLOCKED
  SYSTEM_ERROR
}

enum WhatsAppValidationEventType {
  CREATED
  SENT_REQUEST
  DELIVERY_CONFIRMED
  VALIDATION_ATTEMPT
  VALIDATION_SUCCESS
  VALIDATION_FAILED
  EXPIRED
  BLOCKED
  SYSTEM_ERROR
}

enum WhatsAppValidationStatus {
  PENDING
  SENT
  FAILED
  VALIDATED
}

enum UploadedMediaSource {
  BUSINESS_LOGO
  BUSINESS_COVER
  PROFESSIONAL_AVATAR
  CUSTOMER_AVATAR
  SERVICE_IMAGE
}

enum UserType {
  ADMIN
  CUSTOMER
  PROFESSIONAL
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  CANCELED
  COMPLETED
}

enum AppointmentEventType {
  CREATED
  RESCHEDULED
  CANCELED
  CONFIRMED
  REMINDER_SENT
  CHECKED_IN
  COMPLETED
  NO_SHOW
  COMPLETED_AUTO
  CANCELED_AUTO
  REMINDER_FAILED
}

enum BillingPeriod {
  MONTHLY
  YEARLY
  FREE_TRIAL
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  INCOMPLETE
  INCOMPLETE_EXPIRED
  TRIALING
  UNPAID
}

enum SubscriptionAction {
  CREATED
  UPDATED
  CANCELED
  RENEWED
}

enum PaymentStatus {
  PAID
  FAILED
  PENDING
}

enum ProfessionalStatus {
  ACTIVE
  INACTIVE
  PENDING_VERIFICATION
}

enum BenefitKey {
  PROFESSIONALS // Nº de profissionais que podem ser criados
  REMINDER_CHANNELS // Canais de lembrete (APP, WPP, E-mail)
  CONFIRMATION_ENABLED // Confirmação automática de agendamento
  WAITING_LIST_ENABLED // Lista de espera habilitada?
  REVIEW_REQUEST_ENABLED // Enviar pedido de avaliação após atendimento?
  APP_POSITION // Posição do negócio no app de clientes
}

enum StatementType {
  INCOME
  OUTCOME
}

enum BusinessPublicType {
  MALE
  FEMALE
  BOTH
}
