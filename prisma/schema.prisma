generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
  runtime         = "nodejs"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
  extensions        = [postgis()]
}

model Guest {
  id           String       @id @default(cuid())
  userId       String?      @unique
  user         User?        @relation(fields: [userId], references: [id], name: "UserGuest")
  origin       GuestOrigin  @default(APP)
  device_token String       @unique
  device_info  Json
  push_token   String?
  created_at   DateTime     @default(now())
  updated_at   DateTime     @updatedAt
  GuestVisit   GuestVisit[]

  @@index([device_token], name: "idx_guest_device_token")
}

model User {
  id                  String   @id @default(cuid())
  email               String
  password            String
  temporary_password  String?
  first_access        Boolean  @default(false)
  name                String
  document_number     String?
  push_token          String?
  user_type           UserType
  app_review_eligible Boolean  @default(false)
  created_at          DateTime @default(now())
  updated_at          DateTime @updatedAt

  personId String? @unique
  person   Person? @relation("UserPerson", fields: [personId], references: [id])

  businesses               Business[]                @relation("BusinessOwners")
  professional_profile     ProfessionalProfile[]
  CurrentSelectedBusiness  CurrentSelectedBusiness[]
  guest                    Guest?                    @relation(name: "UserGuest")
  UploadedMedia            UploadedMedia[]
  BusinessRating           BusinessRating[]
  BugReports               BugReports[]
  integrations             UserIntegration[]
  businessRatingPrompts    BusinessRatingPrompt[]
  appUpdateInteractions    AppUpdateInteraction[]
  appReviewEvents          AppReviewEvent[]
  businessPortfolioFolders BusinessPortfolioFolder[]
  businessPortfolioItems   BusinessPortfolioItem[]

  @@unique([email, user_type], name: "uq_user_email_type")
  @@index([email, user_type], name: "idx_user_email_user_type")
}

model InnovateConnectAdmin {
  id            String    @id @default(cuid())
  email         String    @unique
  password_hash String
  is_active     Boolean   @default(true)
  last_login_at DateTime?
  created_at    DateTime  @default(now())
  updated_at    DateTime  @updatedAt

  @@index([email], name: "idx_innovate_connect_admin_email")
  @@index([is_active], name: "idx_innovate_connect_admin_active")
}

model UserIntegration {
  id              String              @id
  userId          String
  provider        IntegrationProvider
  providerAccount String?
  access_token    String?
  refresh_token   String?
  scope           String?
  token_type      String?
  expiry_date     DateTime?
  raw_tokens      Json?
  created_at      DateTime            @default(now())
  updated_at      DateTime            @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@unique([userId, provider], name: "uq_user_provider_integration")
  @@index([provider], name: "idx_integration_provider")
}

model Business {
  id                       String                    @id @default(cuid())
  name                     String
  slug                     String                    @unique
  description              String?
  logo                     String?
  coverImage               String?
  latitude                 Float // Latitude para localização
  longitude                Float // Longitude para localização
  location                 Unsupported("geography")? @map("location")
  opening_hours            Json
  website                  String?
  instagram                String?
  email                    String?
  public_type              BusinessPublicType        @default(BOTH)
  business_category_custom String? // categoria customizada, se aplicável
  is_active                Boolean                   @default(true)
  is_test                  Boolean                   @default(false)
  is_verified              Boolean                   @default(false)
  is_featured              Boolean                   @default(false)
  rating                   Float                     @default(0.0)
  reviews_count            Int                       @default(0)
  total_one_star           Int                       @default(0)
  total_two_star           Int                       @default(0)
  total_three_star         Int                       @default(0)
  total_four_star          Int                       @default(0)
  total_five_star          Int                       @default(0)
  average_price            Float                     @default(0.0) // preço médio dos serviços
  stripe_customer_id       String? // ID do cliente no Stripe, se aplicável
  phone                    String?
  zipCode                  String?
  street                   String?
  neighbourhood            String?
  number                   String?
  complement               String?
  city                     String?
  uf                       String?
  ownerId                  String
  owner                    User                      @relation("BusinessOwners", fields: [ownerId], references: [id])
  professionals            ProfessionalProfile[]
  services                 Service[]
  created_at               DateTime                  @default(now())
  updated_at               DateTime                  @updatedAt
  BusinessCategory         BusinessCategory?         @relation(fields: [businessCategoryId], references: [id])
  businessCategoryId       String?
  BusinessServiceType      BusinessServiceType?      @relation(fields: [businessServiceTypeId], references: [id])
  businessServiceTypeId    String?
  BusinessSubscription     BusinessSubscription[]
  CurrentSelectedBusiness  CurrentSelectedBusiness[]
  ProfessionalStatement    ProfessionalStatement[]
  BusinessCustomer         BusinessCustomer[]
  BusinessRating           BusinessRating[]
  Favorites                Favorite[]
  BusinessReminderSettings BusinessReminderSettings?
  ReminderJob              ReminderJob[]
  ProfessionalTimesBlock   ProfessionalTimesBlock[]
  amenities                BusinessAmenity[]
  businessRatingPrompts    BusinessRatingPrompt[]
  portfolioFolders         BusinessPortfolioFolder[]
  portfolioItems           BusinessPortfolioItem[]

  @@index([slug], name: "idx_business_slug")
  @@index([name], name: "idx_business_name")
  @@index([ownerId], name: "idx_business_owner")
  @@index([businessCategoryId], name: "idx_business_category")
  @@index([businessServiceTypeId], name: "idx_business_service_type")
  @@index([is_test], name: "idx_business_is_test")
  @@index([is_active], name: "idx_business_is_active")
}

model BusinessReminderSettings {
  id         String   @id @default(cuid())
  businessId String   @unique
  business   Business @relation(fields: [businessId], references: [id])

  // Ex.: [1440, 180, 60] => 24h, 3h e 1h antes
  offsets_min_before Int[] @default([1440, 60])

  // Canais habilitados para o negócio
  channels ReminderChannel[] @default([PUSH, WHATSAPP])

  timezone String @default("America/Sao_Paulo")

  is_active  Boolean  @default(true)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([businessId], name: "idx_business_reminder_settings_business")
}

model ReminderJob {
  id               String            @id @default(cuid())
  businessId       String
  appointmentId    String
  personId         String
  channel          ReminderChannel
  due_at_utc       DateTime // quando disparar (UTC)
  scheduled_at_utc DateTime?
  sent_at_utc      DateTime?
  status           ReminderJobStatus @default(PENDING)
  error            String?
  attempts         Int               @default(0)
  metadata         Json?

  business    Business    @relation(fields: [businessId], references: [id])
  appointment Appointment @relation(fields: [appointmentId], references: [id])
  person      Person      @relation(fields: [personId], references: [id])

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  // Evita duplicar o mesmo lembrete do mesmo agendamento/canal/hora
  @@unique([appointmentId, channel, due_at_utc], name: "uq_job_apt_channel_due")
  @@index([status, due_at_utc], name: "idx_job_status_due")
  @@index([businessId], name: "idx_job_business")
  @@index([appointmentId], name: "idx_job_appointment")
}

model BusinessRating {
  id         String   @id @default(cuid())
  rating     Int // 1 a 5
  review     String? // comentário opcional
  created_at DateTime @default(now())

  business      Business @relation(fields: [business_slug], references: [slug])
  user          User     @relation(fields: [userId], references: [id])
  business_slug String
  userId        String

  @@unique([business_slug, userId], name: "uq_business_user_rating") // um usuário só pode avaliar um negócio uma vez
  @@index([business_slug], name: "idx_business_rating_business")
  @@index([userId], name: "idx_business_rating_user")
}

model BusinessRatingPrompt {
  id            String    @id @default(cuid())
  business_slug String
  userId        String
  dismissed_at  DateTime?
  created_at    DateTime  @default(now())
  updated_at    DateTime  @updatedAt

  business Business @relation(fields: [business_slug], references: [slug])
  user     User     @relation(fields: [userId], references: [id])

  @@index([business_slug, userId], name: "idx_rating_prompt_business_user")
  @@index([business_slug], name: "idx_rating_prompt_business")
  @@index([userId], name: "idx_rating_prompt_user")
}

model CurrentSelectedBusiness {
  id         String   @id @default(cuid())
  userId     String   @unique
  businessId String
  user       User     @relation(fields: [userId], references: [id])
  business   Business @relation(fields: [businessId], references: [id])

  @@index([userId], name: "idx_current_selected_business_user")
  @@index([businessId], name: "idx_current_selected_business_business")
}

model Service {
  id             String                @id @default(cuid())
  name           String
  duration       Int // Minutos
  price_in_cents Int // preço padrão do serviço
  businessId     String
  business       Business              @relation(fields: [businessId], references: [id])
  is_active      Boolean               @default(true)
  color          String                @default("#4647fa")
  appointments   Appointment[]
  professionals  ProfessionalService[] // relação com a pivot
  created_at     DateTime              @default(now())
  updated_at     DateTime              @updatedAt

  @@unique([name, businessId]) // evita duplicidade de serviços no mesmo negócio
  @@index([name], name: "idx_service_name")
  @@index([businessId], name: "idx_service_business")
}

model ProfessionalProfile {
  id String @id @default(cuid())

  business_id   String
  business      Business              @relation(fields: [business_id], references: [id])
  services      ProfessionalService[] // relação com a pivot
  bio           String?
  phone         String?
  profile_image String?

  push_notification_enabled  Boolean @default(true)
  email_notification_enabled Boolean @default(true)

  status                 ProfessionalStatus       @default(ACTIVE) // status do profissional
  created_at             DateTime                 @default(now())
  updated_at             DateTime                 @updatedAt
  rating                 Float                    @default(0.0)
  reviewsCount           Int                      @default(0)
  averagePrice           Float                    @default(0.0) // preço médio dos serviços oferecidos
  //availability Json?             // JSON com horários disponíveis (ex: {"Monday": ["09:00", "17:00"], "Tuesday": ["10:00", "18:00"]})
  User                   User?                    @relation(fields: [userId], references: [id])
  userId                 String?
  in_app_notification    InAppNotification[]
  Appointment            Appointment[]
  ProfessionalStatement  ProfessionalStatement[]
  ProfessionalTimesBlock ProfessionalTimesBlock[]

  @@index([business_id], name: "idx_professional_business")
  @@index([userId], name: "idx_professional_user")
  @@index([business_id, id], name: "idx_professional_business_id")
}

model ProfessionalService {
  id                      String  @id @default(cuid())
  professional_profile_id String
  service_id              String
  custom_price            Float? // se diferente do padrão
  active                  Boolean @default(true)
  order                   Int? // para ordenação opcional

  professional_profile ProfessionalProfile @relation(fields: [professional_profile_id], references: [id])
  service              Service             @relation(fields: [service_id], references: [id])

  @@unique([professional_profile_id, service_id]) // evita duplicidade
  @@index([professional_profile_id], name: "idx_professional_service_profile")
  @@index([service_id], name: "idx_professional_service_service")
}

model ProfessionalStatement {
  id             String        @id @default(cuid())
  type           StatementType
  description    String
  value_in_cents Int
  created_at     DateTime      @default(now())

  business Business @relation(fields: [businessId], references: [id])

  professional_profile  ProfessionalProfile @relation(fields: [professionalProfileId], references: [id])
  professionalProfileId String

  appointment   Appointment? @relation(fields: [appointmentId], references: [id])
  appointmentId String?
  businessId    String

  @@index([professionalProfileId], name: "idx_professional_statement_profile")
  @@index([businessId], name: "idx_professional_statement_business")
  @@index([businessId, type, created_at], name: "idx_ps_business_type_created_at")
}

model Appointment {
  id         String            @id @default(cuid())
  service_id String
  status     AppointmentStatus
  notes      String?

  // Sempre UTC
  start_at_utc DateTime
  end_at_utc   DateTime

  // Contexto de fuso e fotografia da duração
  timezone             String @default("America/Sao_Paulo")
  start_offset_minutes Int // ex.: -180
  duration_minutes     Int

  google_calendar_event_id String?

  professional   ProfessionalProfile @relation(fields: [professionalProfileId], references: [id])
  service        Service             @relation(fields: [service_id], references: [id])
  customerPerson Person              @relation(fields: [personId], references: [id])

  created_at            DateTime                @default(now())
  updated_at            DateTime                @updatedAt
  professionalProfileId String
  personId              String
  events                AppointmentEvent[]
  ProfessionalStatement ProfessionalStatement[]
  ReminderJob           ReminderJob[]

  @@index([service_id], name: "idx_appointment_service")
  @@index([personId], name: "idx_appointment_person")
  @@index([professionalProfileId, start_at_utc], name: "idx_professional_start")
  @@index([professionalProfileId, end_at_utc], name: "idx_professional_end")
}

model AppointmentEvent {
  id            String      @id @default(cuid())
  appointmentId String
  appointment   Appointment @relation(fields: [appointmentId], references: [id])

  event_type      AppointmentEventType
  by_professional Boolean
  by_user_id      String?
  reason          String?
  ip              String?              @db.VarChar(64)
  user_agent      String?
  created_at      DateTime             @default(now())

  @@index([appointmentId], name: "idx_appointment_event_appointment")
}

model ProfessionalTimesBlock {
  id String @id @default(cuid())

  professionalProfileId String
  professional          ProfessionalProfile @relation(fields: [professionalProfileId], references: [id])
  businessId            String
  business              Business            @relation(fields: [businessId], references: [id])

  is_all_day   Boolean   @default(false)
  // Sempre UTC
  start_at_utc DateTime?
  end_at_utc   DateTime?

  // Contexto do fuso local que gerou o bloqueio (para conversões reversas)
  timezone             String @default("America/Sao_Paulo")
  start_offset_minutes Int // ex.: -180

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([professionalProfileId, start_at_utc], name: "idx_block_professional_start")
  @@index([businessId], name: "idx_block_business")
}

// Vincular pessoa como user do tipo Customer e vincular como cliente das empresas
model Person {
  id              String  @id @default(cuid())
  // Identificadores para dedupe e match automático
  document_number String? @unique // CPF/CNPJ, limpo e sem máscara
  email           String? @unique // email em minúsculas
  phone           String? @unique // telefone em E.164 (ex: +552199...)

  // Dados básicos
  name          String
  birthdate     DateTime? @db.Date // mantenho como String se preferir
  profile_image String?

  preferred_content_genre BusinessPublicType? // masculino, feminino, ambos

  // Auditoria
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  // Relacionamentos
  user              User?               @relation("UserPerson")
  businessLinks     BusinessCustomer[]
  Appointment       Appointment[]
  InAppNotification InAppNotification[]
  favorites         Favorite[]
  ReminderJob       ReminderJob[]

  @@index([email], name: "idx_person_email")
}

model Favorite {
  id         String   @id @default(cuid())
  personId   String
  businessId String
  created_at DateTime @default(now())

  person   Person   @relation(fields: [personId], references: [id])
  business Business @relation(fields: [businessId], references: [id])

  @@unique([personId, businessId], name: "uq_favorite_person_business")
  @@index([personId], name: "idx_favorite_person")
  @@index([businessId], name: "idx_favorite_business")
}

model BusinessCustomer {
  id         String @id @default(cuid())
  businessId String
  personId   String

  // Propriedades específicas do relacionamento com o negócio
  notes      String?
  verified   Boolean @default(false)
  is_blocked Boolean @default(false)

  // Caso queira manter email/phone “do cadastro do negócio”, deixe como sombra/opcional
  email String?
  phone String?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  business Business @relation(fields: [businessId], references: [id])
  person   Person   @relation(fields: [personId], references: [id])

  @@unique([businessId, personId], name: "uq_business_person")
  @@index([businessId], name: "idx_bc_business")
  @@index([personId], name: "idx_bc_person")
  @@index([businessId, created_at], name: "idx_bc_business_created_at")
}

model BusinessCategory {
  id              String     @id @default(cuid())
  name            String     @unique
  description     String?
  order           Int? // para ordenação na exibição
  icon_path       String? // caminho ou URL do ícone
  icon_path_light String? // caminho ou URL do ícone
  businesses      Business[]

  @@index([name], name: "idx_business_category_name")
}

model BusinessPortfolioFolder {
  id          String   @id @default(cuid())
  businessId  String
  name        String
  description String?
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt
  createdById String?

  business   Business                @relation(fields: [businessId], references: [id])
  created_by User?                   @relation(fields: [createdById], references: [id])
  items      BusinessPortfolioItem[]

  @@index([businessId], name: "idx_portfolio_folder_business")
  @@index([createdById], name: "idx_portfolio_folder_created_by")
  @@index([name], name: "idx_portfolio_folder_name")
}

model BusinessPortfolioItem {
  id           String   @id @default(cuid())
  businessId   String
  folderId     String?
  key          String
  title        String?
  description  String?
  uploadedById String
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  business    Business                 @relation(fields: [businessId], references: [id])
  folder      BusinessPortfolioFolder? @relation(fields: [folderId], references: [id])
  uploaded_by User                     @relation(fields: [uploadedById], references: [id])

  @@index([businessId], name: "idx_portfolio_item_business")
  @@index([folderId], name: "idx_portfolio_item_folder")
  @@index([uploadedById], name: "idx_portfolio_item_uploaded_by")
}

model BusinessServiceType {
  id          String     @id @default(cuid())
  name        String     @unique
  description String?
  businesses  Business[]

  @@index([name], name: "idx_business_service_type_name")
}

model InAppNotification {
  id                    String               @id @default(cuid())
  title                 String
  message               String
  read                  Boolean              @default(false)
  is_visible            Boolean              @default(true)
  // type                 String // tipo da notificação (ex: "appointment", "message", etc.)
  professional_profile  ProfessionalProfile? @relation(fields: [professionalProfileId], references: [id])
  person                Person?              @relation(fields: [personId], references: [id])
  created_at            DateTime             @default(now())
  updated_at            DateTime             @updatedAt
  professionalProfileId String
  personId              String?

  @@index([professionalProfileId], name: "idx_notification_professional")
  @@index([personId], name: "idx_notification_person")
  @@index([created_at], name: "idx_notification_created_at")
  @@index([is_visible], name: "idx_notification_visible")
}

model Plan {
  id          String  @id @default(cuid())
  name        String
  description String?

  plan_id                   String  @unique @default("free_trial") // ID do plano (RevenueCat, AppStore, Play Store...)
  plan_id_play_store        String? // ID do plano na Play Store
  max_professionals_allowed Int     @default(1)

  price_in_cents Int
  billing_period BillingPeriod @default(MONTHLY) // mensal, anual...
  is_active      Boolean       @default(true)
  showing_order  Int? // para ordenação na exibição

  businesses BusinessSubscription[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([plan_id], name: "idx_plan_id")
  @@index([plan_id_play_store], name: "idx_plan_id_play_store")
}

model BusinessSubscription {
  id                   String             @id @default(cuid())
  businessId           String
  planId               String
  status               SubscriptionStatus @default(ACTIVE)
  current_period_start DateTime?
  current_period_end   DateTime?
  cancel_at_period_end Boolean            @default(false)

  business               Business              @relation(fields: [businessId], references: [id])
  plan                   Plan                  @relation(fields: [planId], references: [id])
  subscription_histories SubscriptionHistory[]

  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  Payment    Payment[]

  @@index([businessId])
}

model SubscriptionHistory {
  id                     String             @id @default(cuid())
  businessSubscriptionId String
  action                 SubscriptionAction
  previousPlanId         String? // caso tenha vindo de outro plano
  newPlanId              String? // novo plano
  actionDate             DateTime           @default(now())
  reason                 String? // opcional, motivo da mudança

  businessSubscription BusinessSubscription @relation(fields: [businessSubscriptionId], references: [id])

  @@index([businessSubscriptionId])
}

model Payment {
  id                     String        @id @default(cuid())
  businessSubscriptionId String
  amount_paid_in_cents   Int
  currency               String
  paid_at                DateTime
  status                 PaymentStatus

  businessSubscription BusinessSubscription @relation(fields: [businessSubscriptionId], references: [id])

  created_at DateTime @default(now())

  @@index([businessSubscriptionId])
}

model WebhookEvent {
  id          String   @id @default(cuid())
  event_id    String   @unique
  type        String
  payload     Json
  received_at DateTime @default(now())

  @@index([event_id])
  @@index([type])
}

model UploadedMedia {
  id          String              @id @default(cuid())
  key         String              @unique // chave do objeto no S3
  etag        String?
  source      UploadedMediaSource
  uploaded_by User                @relation(fields: [userId], references: [id])
  created_at  DateTime            @default(now())
  userId      String

  @@index([source], name: "idx_uploaded_media_source")
  @@index([userId], name: "idx_uploaded_media_user")
}

model MailTemplate {
  id          String   @id @default(cuid())
  description String
  type        String
  subject     String
  pre_header  String?
  html        String   @db.Text
  from        String
  active      Boolean  @default(true)
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  @@unique([type, active], name: "uq_mail_template_type_active")
}

model MailValidation {
  id              String                @id @default(cuid())
  request_id      String                @unique
  email           String
  message_id      String?
  code_ciphertext String
  code_iv         String
  type            String
  status          EmailValidationStatus @default(PENDING)
  user_type       UserType
  attempts        Int                   @default(0)
  active          Boolean               @default(true)
  expires_at      DateTime
  validated       Boolean               @default(false)
  validated_at    DateTime?
  created_at      DateTime              @default(now())

  events MailValidationEvent[]

  @@index([email], name: "idx_mail_validation_email")
  @@index([request_id], name: "idx_mail_validation_request")
}

model MailValidationEvent {
  id               String         @id @default(cuid())
  mailValidationId String
  validation       MailValidation @relation(fields: [mailValidationId], references: [id], onDelete: Restrict)

  event_type      EmailValidationEventType
  message         String?                  @db.VarChar(255)
  code_ciphertext String
  code_iv         String
  attempt_no      Int?
  ip              String?                  @db.VarChar(64)
  user_agent      String?
  metadata        Json?
  created_at      DateTime                 @default(now())

  @@index([mailValidationId, created_at], name: "idx_mail_event_stream")
}

model WhatsAppValidation {
  id                  String                    @id @default(cuid())
  request_id          String                    @unique
  phone_number        String
  whatsapp_message_id String?
  code_ciphertext     String
  code_iv             String
  type                String
  status              WhatsAppValidationStatus  @default(PENDING)
  user_type           UserType
  attempts            Int                       @default(0)
  active              Boolean                   @default(true)
  expires_at          DateTime
  validated           Boolean                   @default(false)
  validated_at        DateTime?
  created_at          DateTime                  @default(now())
  events              WhatsAppValidationEvent[]

  @@index([phone_number], name: "idx_whatsapp_validation_phone")
  @@index([request_id], name: "idx_whatsapp_validation_request")
}

model WhatsAppValidationEvent {
  id                   String             @id @default(cuid())
  whatsAppValidationId String
  validation           WhatsAppValidation @relation(fields: [whatsAppValidationId], references: [id], onDelete: Restrict)

  event_type      WhatsAppValidationEventType
  message         String?                     @db.VarChar(255)
  code_ciphertext String
  code_iv         String
  attempt_no      Int?
  ip              String?                     @db.VarChar(64)
  user_agent      String?
  metadata        Json?
  created_at      DateTime                    @default(now())

  @@index([whatsAppValidationId, created_at], name: "idx_wv_event_stream")
}

model BugReports {
  id          String   @id @default(cuid())
  description String   @db.Text
  user        User     @relation(fields: [userId], references: [id])
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  userId String

  @@index([userId], name: "idx_bug_report_user")
}

model Logs {
  id           String   @id @default(cuid())
  body         Json?
  query        Json?
  method       String   @db.VarChar(10)
  endpoint     String
  response     Json?
  success      Boolean
  user_id      String?
  device_token String?
  app_version  String?
  app_os       String?
  datetime     String
  latencyMs    Int?
  created_at   DateTime @default(now())

  @@index([user_id], name: "idx_logs_taxnumber")
  @@index([device_token], name: "idx_logs_device_token")
}

model AppUpdateModal {
  id                     String            @id @default(cuid())
  mode                   AppUpdateMode
  audience               AppUpdateAudience @default(PROFESSIONAL)
  title                  String
  description            String
  banner_url             String?
  whats_new_items        String[]
  primary_button_label   String?
  secondary_button_label String?

  // ✅ Mantém string apenas para visual/log/telemetria
  target_version_ios     String?
  target_version_android String?

  // ✅ Novo: iOS buildNumber / Android versionCode (comparação performática)
  target_build_ios     Int?
  target_build_android Int?

  cta_path   String?
  cta_scope  AppUpdateScope?
  is_active  Boolean         @default(true)
  created_at DateTime        @default(now())
  updated_at DateTime        @updatedAt

  interactions AppUpdateInteraction[]

  @@index([mode], name: "idx_app_update_mode")
  @@index([audience], name: "idx_app_update_audience")
  @@index([is_active], name: "idx_app_update_active")
  // ✅ Índices úteis pro hot path
  @@index([is_active, audience, mode, created_at], name: "idx_app_update_hotpath")
  @@index([target_build_ios], name: "idx_app_update_target_build_ios")
  @@index([target_build_android], name: "idx_app_update_target_build_android")
}

model AppUpdateInteraction {
  id            String          @id @default(cuid())
  app_update_id String
  user_id       String
  action        AppUpdateAction

  // ✅ mantém string para telemetria
  app_version String?
  app_os      String?

  // ✅ novo: buildNumber/versionCode visto no momento da interação
  app_build_number Int?

  created_at DateTime @default(now())

  app_update AppUpdateModal @relation(fields: [app_update_id], references: [id], onDelete: Cascade)
  user       User           @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([app_update_id, user_id, action], name: "uq_app_update_interaction_action")
  @@index([app_update_id], name: "idx_app_update_interaction_update")
  @@index([user_id], name: "idx_app_update_interaction_user")
  // ✅ Ajuda muito no filtro: user_id + action + created_at (cutoff 24h)
  @@index([user_id, action, created_at], name: "idx_app_update_interaction_user_action_created")
}

model AppReviewEvent {
  id          String             @id @default(cuid())
  user_id     String?
  device_id   String?
  platform    AppPlatform
  app_version String?
  event       AppReviewEventType
  context     String?
  created_at  DateTime           @default(now())

  user User? @relation(fields: [user_id], references: [id], onDelete: SetNull)

  @@index([user_id], name: "idx_app_review_user")
  @@index([device_id], name: "idx_app_review_device")
  @@index([event], name: "idx_app_review_event")
  @@index([platform], name: "idx_app_review_platform")
  @@index([created_at], name: "idx_app_review_created")
}

/// Registra acessos de dispositivos à landing/site
model GuestVisit {
  id           String   @id @default(cuid())
  device_token String
  guest        Guest    @relation(fields: [device_token], references: [device_token])
  visited_at   String
  created_at   DateTime @default(now())

  @@index([device_token], name: "idx_guestvisit_device_token")
}

model BusinessAmenity {
  businessId String
  amenityId  String

  business Business  @relation(fields: [businessId], references: [id], onDelete: Cascade)
  amenity  Amenities @relation(fields: [amenityId], references: [id], onDelete: Cascade)

  // ✅ evita duplicar a mesma comodidade no mesmo business
  @@id([businessId, amenityId])
  // ✅ índices úteis p/ filtros
  @@index([amenityId], name: "idx_business_amenity_amenity")
  @@index([businessId], name: "idx_business_amenity_business")
}

model Amenities {
  id    String      @id @default(cuid())
  title String
  type  AmenityType @unique
  icon  String
  lib   String

  // ✅ many-to-many via join table
  businesses BusinessAmenity[]
}

// ENUMS

enum AmenityType {
  wifi
  parking
  free_parking
  air_conditioning
  climatized_environment
  accessibility
  bathroom
  accessible_bathroom
  waiting_room
  tv
  ambient_music
  coffee
  water
  drinks
  pet_friendly
  kids_area
  card_payment
  pix_payment
  cash_payment
  male_service
  female_service
  kids_service
  certified_professionals
  products_for_sale
  private_environment
}

enum GuestOrigin {
  APP
  WEB
}

enum ReminderChannel {
  PUSH
  WHATSAPP
}

enum ReminderJobStatus {
  PENDING
  SCHEDULED
  SENT
  FAILED
  CANCELED
  SKIPPED
}

enum EmailValidationStatus {
  PENDING
  SENT
  FAILED
  VALIDATED
}

enum EmailValidationEventType {
  CREATED
  SENT_REQUEST
  DELIVERY_CONFIRMED
  VALIDATION_ATTEMPT
  VALIDATION_SUCCESS
  VALIDATION_FAILED
  EXPIRED
  BLOCKED
  SYSTEM_ERROR
}

enum WhatsAppValidationEventType {
  CREATED
  SENT_REQUEST
  DELIVERY_CONFIRMED
  VALIDATION_ATTEMPT
  VALIDATION_SUCCESS
  VALIDATION_FAILED
  EXPIRED
  BLOCKED
  SYSTEM_ERROR
}

enum WhatsAppValidationStatus {
  PENDING
  SENT
  FAILED
  VALIDATED
}

enum UploadedMediaSource {
  BUSINESS_LOGO
  BUSINESS_COVER
  PROFESSIONAL_AVATAR
  CUSTOMER_AVATAR
  SERVICE_IMAGE
}

enum AppReviewEventType {
  PROMPT_SHOWN
  PROMPT_DISMISSED
  STORE_OPENED
}

enum AppPlatform {
  IOS
  ANDROID
}

enum UserType {
  ADMIN
  CUSTOMER
  PROFESSIONAL
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  CANCELED
  COMPLETED
}

enum AppointmentEventType {
  CREATED
  RESCHEDULED
  CANCELED
  CONFIRMED
  REMINDER_SENT
  CHECKED_IN
  COMPLETED
  NO_SHOW
  COMPLETED_AUTO
  CANCELED_AUTO
  REMINDER_FAILED
}

enum BillingPeriod {
  MONTHLY
  YEARLY
  FREE_TRIAL
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  INCOMPLETE
  INCOMPLETE_EXPIRED
  TRIALING
  UNPAID
}

enum SubscriptionAction {
  CREATED
  UPDATED
  CANCELED
  RENEWED
}

enum PaymentStatus {
  PAID
  FAILED
  PENDING
}

enum ProfessionalStatus {
  ACTIVE
  INACTIVE
  PENDING_VERIFICATION
}

enum BenefitKey {
  PROFESSIONALS // Nº de profissionais que podem ser criados
  REMINDER_CHANNELS // Canais de lembrete (APP, WPP, E-mail)
  CONFIRMATION_ENABLED // Confirmação automática de agendamento
  WAITING_LIST_ENABLED // Lista de espera habilitada?
  REVIEW_REQUEST_ENABLED // Enviar pedido de avaliação após atendimento?
  APP_POSITION // Posição do negócio no app de clientes
}

enum StatementType {
  INCOME
  OUTCOME
}

enum BusinessPublicType {
  MALE
  FEMALE
  BOTH
}

enum IntegrationProvider {
  GOOGLE_CALENDAR
}

enum AppUpdateMode {
  new_app_version
  whats_new
}

enum AppUpdateAudience {
  CUSTOMER
  PROFESSIONAL
}

enum AppUpdateAction {
  viewed
  dismissed
  primary_clicked
}

enum AppUpdateScope {
  appointments
  clients
  new_appointment
  profile
  statement
}
